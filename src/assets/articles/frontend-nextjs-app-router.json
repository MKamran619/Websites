{
  "id": "frontend-nextjs-app-router",
  "title": "Next.js App Router: The Complete Guide",
  "excerpt": "Master Next.js 14 App Router with server components, layouts, loading states, error handling, and data fetching patterns.",
  "date": "Apr 2023",
  "category": "Modern Frontend",
  "readTime": 15,
  "icon": "⚡",
  "tags": ["Next.js", "App Router", "React", "Full Stack"],
  "featured": false,
  "author": {
    "name": "Kamran Sohail",
    "role": "Software Engineer & Consultant",
    "avatar": "KS"
  },
  "content": "<h2>App Router Fundamentals</h2><p>The App Router is Next.js's file-system based router with built-in support for layouts, server components, streaming, and more.</p><h2>File-System Routing</h2><pre><code>app/\n├── layout.tsx          # Root layout (required)\n├── page.tsx            # Home page (/)\n├── about/\n│   └── page.tsx        # About page (/about)\n├── blog/\n│   ├── page.tsx        # Blog list (/blog)\n│   └── [slug]/\n│       └── page.tsx    # Blog post (/blog/my-post)\n├── (marketing)/        # Route group (no URL impact)\n│   ├── layout.tsx      # Marketing pages layout\n│   ├── pricing/\n│   │   └── page.tsx    # /pricing\n│   └── features/\n│       └── page.tsx    # /features\n└── @modal/             # Parallel route for modals\n    └── login/\n        └── page.tsx</code></pre><h2>Layouts and Templates</h2><pre><code>// app/layout.tsx - Root layout\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode;\n}) {\n  return (\n    <html lang=\"en\">\n      <body>\n        <Header />\n        <main>{children}</main>\n        <Footer />\n      </body>\n    </html>\n  );\n}\n\n// app/dashboard/layout.tsx - Nested layout\nexport default function DashboardLayout({\n  children,\n}: {\n  children: React.ReactNode;\n}) {\n  return (\n    <div className=\"dashboard\">\n      <Sidebar />\n      <div className=\"content\">{children}</div>\n    </div>\n  );\n}\n\n// app/template.tsx - Re-renders on navigation\nexport default function Template({ children }: { children: React.ReactNode }) {\n  return (\n    <div className=\"animate-in\">\n      {children}\n    </div>\n  );\n}</code></pre><h2>Loading UI and Streaming</h2><pre><code>// app/dashboard/loading.tsx\nexport default function Loading() {\n  return (\n    <div className=\"skeleton\">\n      <div className=\"skeleton-header\" />\n      <div className=\"skeleton-content\" />\n    </div>\n  );\n}\n\n// Streaming with Suspense\nimport { Suspense } from 'react';\n\nasync function DashboardPage() {\n  return (\n    <div>\n      <h1>Dashboard</h1>\n      \n      {/* These components stream in as they resolve */}\n      <Suspense fallback={<StatsSkeleton />}>\n        <Stats />\n      </Suspense>\n      \n      <Suspense fallback={<ChartSkeleton />}>\n        <Chart />\n      </Suspense>\n      \n      <Suspense fallback={<TableSkeleton />}>\n        <RecentOrders />\n      </Suspense>\n    </div>\n  );\n}\n\n// Each component can fetch independently\nasync function Stats() {\n  const stats = await fetchStats(); // No loading state blocking\n  return <StatsDisplay data={stats} />;\n}</code></pre><h2>Error Handling</h2><pre><code>// app/dashboard/error.tsx\n'use client';\n\nexport default function Error({\n  error,\n  reset,\n}: {\n  error: Error & { digest?: string };\n  reset: () => void;\n}) {\n  return (\n    <div className=\"error-container\">\n      <h2>Something went wrong!</h2>\n      <p>{error.message}</p>\n      <button onClick={() => reset()}>Try again</button>\n    </div>\n  );\n}\n\n// app/not-found.tsx\nexport default function NotFound() {\n  return (\n    <div>\n      <h2>404 - Page Not Found</h2>\n      <Link href=\"/\">Go home</Link>\n    </div>\n  );\n}</code></pre><h2>Data Fetching</h2><pre><code>// Server Component - Direct data access\nasync function ProductsPage() {\n  // This runs on the server\n  const products = await db.product.findMany();\n  \n  return (\n    <ul>\n      {products.map(product => (\n        <li key={product.id}>{product.name}</li>\n      ))}\n    </ul>\n  );\n}\n\n// Caching and revalidation\nasync function Posts() {\n  // Cached indefinitely (default)\n  const posts = await fetch('https://api.example.com/posts');\n  \n  // Revalidate every hour\n  const news = await fetch('https://api.example.com/news', {\n    next: { revalidate: 3600 }\n  });\n  \n  // No caching\n  const live = await fetch('https://api.example.com/live', {\n    cache: 'no-store'\n  });\n  \n  return (...);\n}</code></pre><h2>Server Actions</h2><pre><code>// app/actions.ts\n'use server';\n\nimport { revalidatePath } from 'next/cache';\nimport { redirect } from 'next/navigation';\n\nexport async function createPost(formData: FormData) {\n  const title = formData.get('title') as string;\n  const content = formData.get('content') as string;\n  \n  // Validation\n  if (!title || !content) {\n    return { error: 'Title and content required' };\n  }\n  \n  // Create in database\n  const post = await db.post.create({\n    data: { title, content }\n  });\n  \n  // Revalidate and redirect\n  revalidatePath('/posts');\n  redirect(`/posts/${post.id}`);\n}\n\n// Using in form\nexport default function NewPostForm() {\n  return (\n    <form action={createPost}>\n      <input name=\"title\" placeholder=\"Title\" />\n      <textarea name=\"content\" placeholder=\"Content\" />\n      <button type=\"submit\">Create Post</button>\n    </form>\n  );\n}\n\n// With useFormState for handling errors\n'use client';\n\nimport { useFormState } from 'react-dom';\nimport { createPost } from './actions';\n\nexport function PostForm() {\n  const [state, formAction] = useFormState(createPost, null);\n  \n  return (\n    <form action={formAction}>\n      <input name=\"title\" />\n      {state?.error && <p className=\"error\">{state.error}</p>}\n      <button>Submit</button>\n    </form>\n  );\n}</code></pre><h2>Middleware</h2><pre><code>// middleware.ts\nimport { NextResponse } from 'next/server';\nimport type { NextRequest } from 'next/server';\n\nexport function middleware(request: NextRequest) {\n  // Check authentication\n  const token = request.cookies.get('token');\n  \n  if (!token && request.nextUrl.pathname.startsWith('/dashboard')) {\n    return NextResponse.redirect(new URL('/login', request.url));\n  }\n  \n  // Add headers\n  const response = NextResponse.next();\n  response.headers.set('x-request-id', crypto.randomUUID());\n  \n  return response;\n}\n\nexport const config = {\n  matcher: ['/dashboard/:path*', '/api/:path*']\n};</code></pre><h2>Conclusion</h2><p>The App Router brings React Server Components to Next.js with file-based routing, layouts, and streaming. Embrace server-first rendering for better performance and simpler code.</p>"
}
