{
  "id": "system-architecture-database-per-service",
  "title": "Database per Service: Data Management in Microservices",
  "excerpt": "Navigate the complexities of distributed data management with strategies for data isolation, consistency, and cross-service queries.",
  "date": "Aug 2023",
  "category": "System Architecture",
  "readTime": 12,
  "icon": "üèóÔ∏è",
  "tags": ["Database", "Microservices", "Data Management", "Architecture"],
  "featured": false,
  "author": {
    "name": "Kamran Sohail",
    "role": "Software Engineer & Consultant",
    "avatar": "KS"
  },
  "content": "<h2>The Database per Service Pattern</h2><p>Each microservice owns its data exclusively. No other service can access another service's database directly. This ensures loose coupling and independent deployability.</p><h2>Why Separate Databases?</h2><h3>Benefits</h3><ul><li><strong>Loose Coupling:</strong> Services can change their schema without affecting others</li><li><strong>Technology Freedom:</strong> Use the right database for each service's needs</li><li><strong>Independent Scaling:</strong> Scale databases based on individual service needs</li><li><strong>Failure Isolation:</strong> One database failure doesn't cascade</li></ul><h3>Challenges</h3><ul><li>Cross-service queries become complex</li><li>Maintaining data consistency is harder</li><li>Reporting across services requires aggregation</li></ul><h2>Data Isolation Strategies</h2><h3>Separate Database Servers</h3><p>Maximum isolation but highest operational overhead:</p><pre><code>Orders Service ‚Üí PostgreSQL (orders-db.example.com)\nInventory Service ‚Üí MongoDB (inventory-db.example.com)\nAnalytics Service ‚Üí ClickHouse (analytics-db.example.com)</code></pre><h3>Shared Server, Separate Databases</h3><p>Reduces operational overhead while maintaining logical separation:</p><pre><code>PostgreSQL Server\n‚îú‚îÄ‚îÄ orders_db (Orders Service)\n‚îú‚îÄ‚îÄ customers_db (Customers Service)\n‚îî‚îÄ‚îÄ payments_db (Payments Service)</code></pre><h3>Shared Database, Separate Schemas</h3><p>Minimum isolation, suitable for early microservices migration:</p><pre><code>PostgreSQL Database\n‚îú‚îÄ‚îÄ orders schema\n‚îú‚îÄ‚îÄ customers schema\n‚îî‚îÄ‚îÄ payments schema</code></pre><h2>Cross-Service Data Access</h2><h3>API Composition</h3><p>Aggregate data through service APIs:</p><pre><code>async function getOrderDetails(orderId) {\n  const order = await ordersService.getOrder(orderId);\n  const customer = await customersService.getCustomer(order.customerId);\n  const items = await Promise.all(\n    order.itemIds.map(id => inventoryService.getItem(id))\n  );\n  return { ...order, customer, items };\n}</code></pre><h3>Data Replication via Events</h3><p>Maintain local copies of needed data:</p><pre><code>// Customers Service publishes\nCustomerUpdated { id, name, email }\n\n// Orders Service subscribes and maintains local copy\nCREATE TABLE customer_cache (\n  id UUID PRIMARY KEY,\n  name VARCHAR,\n  email VARCHAR,\n  updated_at TIMESTAMP\n);</code></pre><h3>CQRS for Reporting</h3><p>Build dedicated read models that aggregate data from multiple services for reporting needs.</p><h2>Consistency Patterns</h2><h3>Eventual Consistency</h3><p>Accept that data will be consistent eventually. Design UIs that communicate this clearly.</p><h3>Saga Pattern</h3><p>Coordinate distributed transactions with compensating actions for failures.</p><h3>Outbox Pattern</h3><p>Ensure reliable event publishing with database transactions:</p><pre><code>BEGIN TRANSACTION;\n  INSERT INTO orders VALUES (...);\n  INSERT INTO outbox (event_type, payload) \n    VALUES ('OrderCreated', '{...}');\nCOMMIT;</code></pre><h2>Choosing the Right Database</h2><ul><li><strong>Orders:</strong> PostgreSQL for ACID transactions</li><li><strong>Product Catalog:</strong> MongoDB for flexible schemas</li><li><strong>Session Data:</strong> Redis for fast access</li><li><strong>Search:</strong> Elasticsearch for full-text search</li><li><strong>Analytics:</strong> ClickHouse for OLAP queries</li></ul><h2>Conclusion</h2><p>Database per service is fundamental to microservices success. Plan your data management strategy carefully and choose patterns that match your consistency requirements.</p>"
}
