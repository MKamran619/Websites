{
  "id": "frontend-react-server-components",
  "title": "React Server Components: A Complete Guide",
  "excerpt": "Understand React Server Components (RSC), when to use them, and how they change the way we build React applications with Next.js App Router.",
  "date": "Dec 2023",
  "category": "Modern Frontend",
  "readTime": 14,
  "icon": "âš¡",
  "tags": ["React", "RSC", "Next.js", "Server Components"],
  "featured": false,
  "author": {
    "name": "Kamran Sohail",
    "role": "Software Engineer & Consultant",
    "avatar": "KS"
  },
  "content": "<h2>What Are Server Components?</h2><p>React Server Components (RSC) render on the server and send HTML to the client. They can access backend resources directly without exposing APIs to the client.</p><h2>Server vs Client Components</h2><pre><code>// Server Component (default in App Router)\n// app/products/page.tsx\nasync function ProductsPage() {\n  // Direct database access - no API needed!\n  const products = await db.product.findMany();\n  \n  return (\n    <div>\n      {products.map(product => (\n        <ProductCard key={product.id} product={product} />\n      ))}\n    </div>\n  );\n}\n\n// Client Component\n// components/AddToCartButton.tsx\n'use client';\n\nimport { useState } from 'react';\n\nexport function AddToCartButton({ productId }: { productId: string }) {\n  const [loading, setLoading] = useState(false);\n  \n  const addToCart = async () => {\n    setLoading(true);\n    await fetch('/api/cart', {\n      method: 'POST',\n      body: JSON.stringify({ productId })\n    });\n    setLoading(false);\n  };\n  \n  return (\n    <button onClick={addToCart} disabled={loading}>\n      {loading ? 'Adding...' : 'Add to Cart'}\n    </button>\n  );\n}</code></pre><h2>When to Use Each</h2><h3>Server Components (Default)</h3><ul><li>Fetching data</li><li>Accessing backend resources</li><li>Keeping sensitive info on server</li><li>Large dependencies</li></ul><h3>Client Components ('use client')</h3><ul><li>Interactivity (onClick, onChange)</li><li>useState, useEffect, useContext</li><li>Browser APIs</li><li>Custom hooks with state</li></ul><h2>Data Fetching Patterns</h2><pre><code>// Parallel data fetching\nasync function Dashboard() {\n  // These run in parallel\n  const [user, orders, recommendations] = await Promise.all([\n    getUser(),\n    getOrders(),\n    getRecommendations()\n  ]);\n  \n  return (\n    <div>\n      <UserProfile user={user} />\n      <OrderList orders={orders} />\n      <Recommendations items={recommendations} />\n    </div>\n  );\n}\n\n// Sequential with Suspense\nasync function ProductPage({ id }: { id: string }) {\n  const product = await getProduct(id);\n  \n  return (\n    <div>\n      <h1>{product.name}</h1>\n      <Suspense fallback={<ReviewsSkeleton />}>\n        <Reviews productId={id} />\n      </Suspense>\n    </div>\n  );\n}\n\nasync function Reviews({ productId }: { productId: string }) {\n  const reviews = await getReviews(productId); // Loads independently\n  return <ReviewList reviews={reviews} />;\n}</code></pre><h2>Composition Patterns</h2><pre><code>// Server Component wrapping Client Component\n// app/posts/[id]/page.tsx\nimport { CommentForm } from './CommentForm'; // client component\n\nasync function PostPage({ params }: { params: { id: string } }) {\n  const post = await getPost(params.id);\n  const comments = await getComments(params.id);\n  \n  return (\n    <article>\n      <h1>{post.title}</h1>\n      <div>{post.content}</div>\n      \n      {/* Pass server data to client component */}\n      <CommentForm postId={params.id} />\n      \n      {/* Server-rendered comments */}\n      <CommentList comments={comments} />\n    </article>\n  );\n}\n\n// Client Component receiving children\n'use client';\n\nexport function Modal({ children }: { children: React.ReactNode }) {\n  const [open, setOpen] = useState(false);\n  \n  return (\n    <>\n      <button onClick={() => setOpen(true)}>Open</button>\n      {open && (\n        <div className=\"modal\">\n          {children} {/* Can be Server Components! */}\n        </div>\n      )}\n    </>\n  );\n}</code></pre><h2>Server Actions</h2><pre><code>// Direct server mutations\n// app/actions.ts\n'use server';\n\nexport async function createPost(formData: FormData) {\n  const title = formData.get('title') as string;\n  const content = formData.get('content') as string;\n  \n  await db.post.create({\n    data: { title, content }\n  });\n  \n  revalidatePath('/posts');\n}\n\n// Use in component\nimport { createPost } from './actions';\n\nfunction NewPostForm() {\n  return (\n    <form action={createPost}>\n      <input name=\"title\" />\n      <textarea name=\"content\" />\n      <button type=\"submit\">Create Post</button>\n    </form>\n  );\n}</code></pre><h2>Caching and Revalidation</h2><pre><code>// Time-based revalidation\nasync function Products() {\n  const products = await fetch('https://api.example.com/products', {\n    next: { revalidate: 3600 } // Revalidate every hour\n  }).then(r => r.json());\n  \n  return <ProductList products={products} />;\n}\n\n// On-demand revalidation\n'use server';\n\nexport async function updateProduct(id: string, data: ProductData) {\n  await db.product.update({ where: { id }, data });\n  revalidatePath('/products');\n  revalidateTag('products');\n}</code></pre><h2>Best Practices</h2><ul><li>Start with Server Components, add 'use client' when needed</li><li>Keep client components small and focused</li><li>Pass serializable props between server and client</li><li>Use Suspense for loading states</li><li>Colocate data fetching with components</li></ul><h2>Conclusion</h2><p>Server Components fundamentally change React development. They simplify data fetching, reduce bundle size, and improve performance. Embrace the server-first mindset.</p>"
}
