{
  "id": "performance-caching-strategies",
  "title": "Caching Strategies: From Browser to Database",
  "excerpt": "Implement effective caching at every layer of your application stack to dramatically improve performance and reduce infrastructure costs.",
  "date": "Nov 2023",
  "category": "Performance",
  "readTime": 12,
  "icon": "⚡",
  "tags": ["Caching", "Redis", "CDN", "Performance"],
  "featured": false,
  "author": {
    "name": "Kamran Sohail",
    "role": "Software Engineer & Consultant",
    "avatar": "KS"
  },
  "content": "<h2>The Caching Pyramid</h2><p>Effective caching happens at multiple layers. Each layer serves different purposes and has different characteristics.</p><pre><code>Browser Cache\n    ↓\nCDN Cache\n    ↓\nAPI Gateway Cache\n    ↓\nApplication Cache\n    ↓\nDatabase Cache</code></pre><h2>Browser Caching</h2><h3>Cache-Control Headers</h3><pre><code>// Static assets - cache for 1 year\nCache-Control: public, max-age=31536000, immutable\n\n// API responses - cache with revalidation\nCache-Control: private, max-age=0, must-revalidate\nETag: \"abc123\"</code></pre><h3>Service Worker Caching</h3><pre><code>// Cache-first strategy for static assets\nself.addEventListener('fetch', (event) => {\n  event.respondWith(\n    caches.match(event.request).then((cached) => {\n      return cached || fetch(event.request);\n    })\n  );\n});</code></pre><h2>CDN Caching</h2><ul><li>Cache static assets globally</li><li>Use cache keys wisely (URL, headers, cookies)</li><li>Implement cache purging for updates</li><li>Consider edge computing for dynamic content</li></ul><pre><code>// CloudFront cache behavior\n{\n  \"PathPattern\": \"/static/*\",\n  \"TTL\": {\n    \"DefaultTTL\": 86400,\n    \"MaxTTL\": 31536000\n  },\n  \"CacheKeyPolicy\": \"CachingOptimized\"\n}</code></pre><h2>Application Caching</h2><h3>In-Memory Cache</h3><pre><code>// Node.js with node-cache\nconst NodeCache = require('node-cache');\nconst cache = new NodeCache({ stdTTL: 600 });\n\nasync function getUser(id) {\n  const cached = cache.get(`user:${id}`);\n  if (cached) return cached;\n  \n  const user = await db.users.findById(id);\n  cache.set(`user:${id}`, user);\n  return user;\n}</code></pre><h3>Distributed Cache (Redis)</h3><pre><code>const redis = require('redis');\nconst client = redis.createClient();\n\nasync function getProduct(id) {\n  // Try cache first\n  const cached = await client.get(`product:${id}`);\n  if (cached) return JSON.parse(cached);\n  \n  // Fetch from database\n  const product = await db.products.findById(id);\n  \n  // Cache with expiration\n  await client.setEx(`product:${id}`, 3600, JSON.stringify(product));\n  \n  return product;\n}</code></pre><h2>Cache Patterns</h2><h3>Cache-Aside (Lazy Loading)</h3><pre><code>// Application manages cache explicitly\nasync function getData(key) {\n  let data = await cache.get(key);\n  if (!data) {\n    data = await database.get(key);\n    await cache.set(key, data, TTL);\n  }\n  return data;\n}</code></pre><h3>Write-Through</h3><pre><code>// Write to cache and database together\nasync function saveData(key, value) {\n  await database.save(key, value);\n  await cache.set(key, value);\n}</code></pre><h3>Write-Behind</h3><pre><code>// Write to cache immediately, database asynchronously\nasync function saveData(key, value) {\n  await cache.set(key, value);\n  queue.add({ key, value }); // Process later\n}</code></pre><h2>Cache Invalidation</h2><p>\"There are only two hard things in Computer Science: cache invalidation and naming things.\"</p><h3>Strategies</h3><ul><li><strong>TTL-based:</strong> Data expires after set time</li><li><strong>Event-based:</strong> Invalidate on data changes</li><li><strong>Version-based:</strong> Include version in cache key</li></ul><pre><code>// Event-based invalidation\nasync function updateProduct(id, data) {\n  await db.products.update(id, data);\n  await cache.delete(`product:${id}`);\n  await cache.delete(`products:list`); // Invalidate related caches\n}</code></pre><h2>Conclusion</h2><p>Caching is essential for performance but adds complexity. Start simple, measure impact, and add sophistication only where needed.</p>"
}
