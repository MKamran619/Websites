{
  "id": "system-architecture-hexagonal",
  "title": "Hexagonal Architecture: Ports and Adapters Pattern",
  "excerpt": "Build maintainable applications with clean boundaries using hexagonal architecture. Learn to isolate your domain logic from infrastructure concerns.",
  "date": "Nov 2023",
  "category": "System Architecture",
  "readTime": 12,
  "icon": "ğŸ—ï¸",
  "tags": ["Hexagonal", "Clean Architecture", "Ports", "Adapters"],
  "featured": false,
  "author": {
    "name": "Kamran Sohail",
    "role": "Software Engineer & Consultant",
    "avatar": "KS"
  },
  "content": "<h2>Introduction to Hexagonal Architecture</h2><p>Hexagonal Architecture, also known as Ports and Adapters, was introduced by Alistair Cockburn. It aims to create loosely coupled application components that can be easily connected to their software environment.</p><h2>Core Concepts</h2><h3>The Domain (Hexagon Center)</h3><p>The core business logic lives at the center, completely independent of external concerns. It contains entities, value objects, domain services, and business rules.</p><h3>Ports</h3><p>Ports are interfaces that define how the outside world can interact with your domain. There are two types:</p><ul><li><strong>Driving Ports (Primary):</strong> Define how external actors use your application (e.g., API controllers)</li><li><strong>Driven Ports (Secondary):</strong> Define what your application needs from external services (e.g., repositories)</li></ul><h3>Adapters</h3><p>Adapters implement ports to connect your domain to the outside world:</p><ul><li><strong>Driving Adapters:</strong> REST controllers, CLI commands, message handlers</li><li><strong>Driven Adapters:</strong> Database repositories, external API clients, file system handlers</li></ul><h2>Implementation Example</h2><h3>Domain Layer</h3><pre><code>// Domain Entity\npublic class Order {\n    public Guid Id { get; private set; }\n    public OrderStatus Status { get; private set; }\n    \n    public void Ship() {\n        if (Status != OrderStatus.Paid)\n            throw new DomainException(\"Order must be paid before shipping\");\n        Status = OrderStatus.Shipped;\n    }\n}</code></pre><h3>Driven Port (Interface)</h3><pre><code>// Port - defined in domain layer\npublic interface IOrderRepository {\n    Task&lt;Order&gt; GetById(Guid id);\n    Task Save(Order order);\n}</code></pre><h3>Driven Adapter (Implementation)</h3><pre><code>// Adapter - in infrastructure layer\npublic class SqlOrderRepository : IOrderRepository {\n    private readonly DbContext _context;\n    \n    public async Task&lt;Order&gt; GetById(Guid id) {\n        return await _context.Orders.FindAsync(id);\n    }\n    \n    public async Task Save(Order order) {\n        _context.Orders.Update(order);\n        await _context.SaveChangesAsync();\n    }\n}</code></pre><h3>Application Service</h3><pre><code>public class ShipOrderUseCase {\n    private readonly IOrderRepository _repository;\n    \n    public async Task Execute(Guid orderId) {\n        var order = await _repository.GetById(orderId);\n        order.Ship();\n        await _repository.Save(order);\n    }\n}</code></pre><h2>Benefits</h2><ul><li><strong>Testability:</strong> Domain logic can be tested without infrastructure</li><li><strong>Flexibility:</strong> Swap adapters without changing domain</li><li><strong>Focus:</strong> Domain remains pure business logic</li><li><strong>Independence:</strong> Technology decisions are deferred</li></ul><h2>Project Structure</h2><pre><code>src/\nâ”œâ”€â”€ Domain/\nâ”‚   â”œâ”€â”€ Entities/\nâ”‚   â”œâ”€â”€ ValueObjects/\nâ”‚   â””â”€â”€ Ports/\nâ”œâ”€â”€ Application/\nâ”‚   â””â”€â”€ UseCases/\nâ””â”€â”€ Infrastructure/\n    â”œâ”€â”€ Persistence/\n    â”œâ”€â”€ Api/\n    â””â”€â”€ ExternalServices/</code></pre><h2>Conclusion</h2><p>Hexagonal architecture creates clear boundaries that make your application more maintainable and testable. The initial investment in structure pays dividends as your application grows.</p>"
}
