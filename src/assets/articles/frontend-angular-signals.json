{
  "id": "frontend-angular-signals",
  "title": "Angular Signals: The Future of Reactivity",
  "excerpt": "Master Angular's new signals API for fine-grained reactivity, computed values, and effects that simplify state management and improve performance.",
  "date": "Jan 2024",
  "category": "Modern Frontend",
  "readTime": 12,
  "icon": "âš¡",
  "tags": ["Angular", "Signals", "Reactivity", "Performance"],
  "featured": false,
  "author": {
    "name": "Kamran Sohail",
    "role": "Software Engineer & Consultant",
    "avatar": "KS"
  },
  "content": "<h2>What Are Signals?</h2><p>Signals are a new reactive primitive in Angular that provide fine-grained reactivity. Unlike observables, signals are synchronous and automatically track dependencies.</p><h2>Basic Signal Usage</h2><pre><code>import { signal, computed, effect } from '@angular/core';\n\n@Component({\n  selector: 'app-counter',\n  template: `\n    <p>Count: {{ count() }}</p>\n    <p>Double: {{ doubleCount() }}</p>\n    <button (click)=\"increment()\">Increment</button>\n  `\n})\nexport class CounterComponent {\n  // Create a writable signal\n  count = signal(0);\n  \n  // Create a computed signal (read-only, derived value)\n  doubleCount = computed(() => this.count() * 2);\n  \n  increment() {\n    // Update signal value\n    this.count.update(value => value + 1);\n    // Or set directly: this.count.set(10);\n  }\n}</code></pre><h2>Effects</h2><p>Effects run side effects when signals change:</p><pre><code>@Component({...})\nexport class UserComponent {\n  userId = signal<string | null>(null);\n  user = signal<User | null>(null);\n  \n  constructor() {\n    // Effect runs when userId changes\n    effect(async () => {\n      const id = this.userId();\n      if (id) {\n        const userData = await this.userService.getUser(id);\n        this.user.set(userData);\n      }\n    });\n  }\n}</code></pre><h2>Signal-Based Inputs</h2><pre><code>@Component({\n  selector: 'app-user-card',\n  template: `\n    <div class=\"card\">\n      <h3>{{ fullName() }}</h3>\n      <p>{{ user().email }}</p>\n    </div>\n  `\n})\nexport class UserCardComponent {\n  // Signal-based input\n  user = input.required<User>();\n  \n  // Computed from input\n  fullName = computed(() => \n    `${this.user().firstName} ${this.user().lastName}`\n  );\n}</code></pre><h2>Signal-Based Outputs</h2><pre><code>@Component({\n  selector: 'app-search',\n  template: `\n    <input \n      [value]=\"query()\" \n      (input)=\"onInput($event)\" \n    />\n  `\n})\nexport class SearchComponent {\n  query = signal('');\n  \n  // Output using outputFromObservable or output()\n  searchChange = output<string>();\n  \n  onInput(event: Event) {\n    const value = (event.target as HTMLInputElement).value;\n    this.query.set(value);\n    this.searchChange.emit(value);\n  }\n}</code></pre><h2>State Management with Signals</h2><pre><code>// Simple store using signals\n@Injectable({ providedIn: 'root' })\nexport class CartStore {\n  private items = signal<CartItem[]>([]);\n  \n  // Public read-only access\n  readonly cartItems = this.items.asReadonly();\n  \n  readonly totalItems = computed(() => \n    this.items().reduce((sum, item) => sum + item.quantity, 0)\n  );\n  \n  readonly totalPrice = computed(() =>\n    this.items().reduce((sum, item) => sum + item.price * item.quantity, 0)\n  );\n  \n  addItem(product: Product) {\n    this.items.update(items => {\n      const existing = items.find(i => i.productId === product.id);\n      if (existing) {\n        return items.map(i => \n          i.productId === product.id \n            ? { ...i, quantity: i.quantity + 1 }\n            : i\n        );\n      }\n      return [...items, { productId: product.id, quantity: 1, price: product.price }];\n    });\n  }\n  \n  removeItem(productId: string) {\n    this.items.update(items => items.filter(i => i.productId !== productId));\n  }\n}</code></pre><h2>Converting from RxJS</h2><pre><code>import { toSignal, toObservable } from '@angular/core/rxjs-interop';\n\n@Component({...})\nexport class DataComponent {\n  private http = inject(HttpClient);\n  \n  // Convert Observable to Signal\n  users = toSignal(\n    this.http.get<User[]>('/api/users'),\n    { initialValue: [] }\n  );\n  \n  selectedId = signal<string | null>(null);\n  \n  // Convert Signal to Observable\n  selectedId$ = toObservable(this.selectedId);\n}</code></pre><h2>Performance Benefits</h2><ul><li>Fine-grained updates - only affected components re-render</li><li>No zone.js dependency with zoneless change detection</li><li>Synchronous reads - no async complexity</li><li>Automatic dependency tracking</li></ul><h2>Best Practices</h2><ul><li>Use signals for component state</li><li>Use computed for derived values</li><li>Use effects sparingly for side effects</li><li>Keep signals close to where they're used</li><li>Consider signal-based stores for shared state</li></ul><h2>Conclusion</h2><p>Signals represent Angular's evolution toward simpler, more performant reactivity. Start using them in new components and gradually migrate existing code.</p>"
}
