{
  "id": "system-architecture-cqrs",
  "title": "CQRS Pattern: Separating Reads from Writes",
  "excerpt": "Understand Command Query Responsibility Segregation and when to apply this powerful pattern for complex enterprise applications.",
  "date": "Nov 2023",
  "category": "System Architecture",
  "readTime": 13,
  "icon": "üèóÔ∏è",
  "tags": ["CQRS", "Architecture", "Patterns", "Scalability"],
  "featured": false,
  "author": {
    "name": "Kamran Sohail",
    "role": "Software Engineer & Consultant",
    "avatar": "KS"
  },
  "content": "<h2>What is CQRS?</h2><p>Command Query Responsibility Segregation (CQRS) is a pattern that separates read and write operations for a data store. The write model (commands) and read model (queries) can be optimized independently.</p><h2>Why CQRS?</h2><h3>Different Requirements</h3><p>Read and write operations often have vastly different requirements:</p><ul><li>Reads need fast, denormalized data for display</li><li>Writes need normalized data with business rule validation</li><li>Read/write ratios are often 90/10 or higher</li></ul><h3>Benefits</h3><ul><li>Independent scaling of read and write workloads</li><li>Optimized data schemas for each operation type</li><li>Simplified queries without complex joins</li><li>Better security through separated concerns</li></ul><h2>Implementation</h2><h3>Command Side</h3><pre><code>public class CreateOrderCommand {\n    public Guid CustomerId { get; set; }\n    public List&lt;OrderItem&gt; Items { get; set; }\n}\n\npublic class CreateOrderHandler {\n    public async Task Handle(CreateOrderCommand cmd) {\n        var order = new Order(cmd.CustomerId, cmd.Items);\n        await _repository.Save(order);\n        await _eventBus.Publish(new OrderCreated(order.Id));\n    }\n}</code></pre><h3>Query Side</h3><pre><code>public class OrderSummaryQuery {\n    public Guid OrderId { get; set; }\n}\n\npublic class OrderSummaryHandler {\n    public async Task&lt;OrderSummaryDto&gt; Handle(OrderSummaryQuery query) {\n        return await _readDb.QueryFirstAsync&lt;OrderSummaryDto&gt;(\n            \"SELECT * FROM OrderSummaries WHERE Id = @Id\",\n            new { Id = query.OrderId }\n        );\n    }\n}</code></pre><h2>Data Synchronization</h2><h3>Event-Based Sync</h3><p>Commands publish domain events that update the read model:</p><pre><code>public class OrderCreatedHandler : IEventHandler&lt;OrderCreated&gt; {\n    public async Task Handle(OrderCreated evt) {\n        await _readDb.ExecuteAsync(@\"\n            INSERT INTO OrderSummaries (Id, CustomerName, Total, Status)\n            SELECT o.Id, c.Name, o.Total, o.Status\n            FROM Orders o JOIN Customers c ON o.CustomerId = c.Id\n            WHERE o.Id = @Id\",\n            new { Id = evt.OrderId }\n        );\n    }\n}</code></pre><h3>Eventual Consistency</h3><p>The read model may lag behind the write model. Design your UI to handle this gracefully.</p><h2>When to Use CQRS</h2><h3>Good Candidates</h3><ul><li>Complex domains with many business rules</li><li>High read/write ratio applications</li><li>Systems requiring independent scaling</li><li>Event-sourced systems</li></ul><h3>When to Avoid</h3><ul><li>Simple CRUD applications</li><li>Small teams without DDD experience</li><li>Systems requiring strong consistency</li></ul><h2>CQRS + Event Sourcing</h2><p>CQRS pairs naturally with Event Sourcing. Events become the mechanism for syncing write and read models while providing a complete audit trail.</p><h2>Conclusion</h2><p>CQRS adds complexity but provides powerful benefits for the right use cases. Start simple and introduce CQRS when the complexity of your domain justifies it.</p>"
}
