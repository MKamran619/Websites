{
  "id": "security-secure-coding",
  "title": "Secure Coding Practices Every Developer Must Know",
  "excerpt": "Write secure code by understanding common vulnerabilities, input validation, output encoding, and secure handling of sensitive data.",
  "date": "Aug 2023",
  "category": "Security",
  "readTime": 12,
  "icon": "ðŸ”’",
  "tags": ["Secure Coding", "OWASP", "Vulnerabilities", "Best Practices"],
  "featured": false,
  "author": {
    "name": "Kamran Sohail",
    "role": "Software Engineer & Consultant",
    "avatar": "KS"
  },
  "content": "<h2>Security is Everyone's Responsibility</h2><p>Security vulnerabilities often originate in code. Understanding common attack patterns and defensive coding practices prevents breaches.</p><h2>Input Validation</h2><h3>Never Trust User Input</h3><pre><code>// BAD - Using user input directly\nconst query = `SELECT * FROM users WHERE id = ${req.params.id}`;\n\n// GOOD - Parameterized query\nconst query = 'SELECT * FROM users WHERE id = $1';\nconst result = await db.query(query, [req.params.id]);\n\n// GOOD - Schema validation with Zod\nimport { z } from 'zod';\n\nconst UserIdSchema = z.object({\n  id: z.string().uuid()\n});\n\nfunction getUser(req, res) {\n  const result = UserIdSchema.safeParse(req.params);\n  if (!result.success) {\n    return res.status(400).json({ error: 'Invalid user ID' });\n  }\n  // Now safe to use result.data.id\n}</code></pre><h3>Whitelist vs Blacklist</h3><pre><code>// BAD - Blacklist approach (trying to block bad input)\nfunction sanitize(input) {\n  return input.replace(/<script>/gi, '');  // Can be bypassed!\n}\n\n// GOOD - Whitelist approach (only allow known good)\nfunction sanitize(input) {\n  return input.replace(/[^a-zA-Z0-9\\s]/g, '');\n}\n\n// BETTER - Use dedicated libraries\nimport DOMPurify from 'dompurify';\nconst clean = DOMPurify.sanitize(userHtml);</code></pre><h2>Output Encoding</h2><h3>XSS Prevention</h3><pre><code>// BAD - Inserting user data into HTML\nelement.innerHTML = `<p>Hello, ${userName}</p>`;\n\n// GOOD - Use textContent for plain text\nelement.textContent = `Hello, ${userName}`;\n\n// GOOD - Encode HTML entities\nfunction escapeHtml(text) {\n  const map = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#039;'\n  };\n  return text.replace(/[&<>\"']/g, m => map[m]);\n}\n\n// GOOD - Use framework's built-in escaping\n// React automatically escapes: <p>{userName}</p>\n// Angular automatically escapes: <p>{{userName}}</p></code></pre><h2>SQL Injection Prevention</h2><pre><code>// Always use parameterized queries\n// Node.js with pg\nconst { rows } = await pool.query(\n  'SELECT * FROM products WHERE category = $1 AND price < $2',\n  [category, maxPrice]\n);\n\n// Python with psycopg2\ncursor.execute(\n    \"SELECT * FROM products WHERE category = %s AND price < %s\",\n    (category, max_price)\n)\n\n// C# with Entity Framework (safe by default)\nvar products = context.Products\n    .Where(p => p.Category == category && p.Price < maxPrice)\n    .ToList();</code></pre><h2>Path Traversal Prevention</h2><pre><code>import path from 'path';\n\n// BAD - User can access any file\napp.get('/files/:filename', (req, res) => {\n  res.sendFile(`/uploads/${req.params.filename}`);\n});\n\n// GOOD - Validate and sanitize path\napp.get('/files/:filename', (req, res) => {\n  const uploadsDir = '/var/www/uploads';\n  const filename = path.basename(req.params.filename);  // Strip path\n  const filePath = path.join(uploadsDir, filename);\n  \n  // Verify file is within allowed directory\n  if (!filePath.startsWith(uploadsDir)) {\n    return res.status(403).send('Access denied');\n  }\n  \n  res.sendFile(filePath);\n});</code></pre><h2>Sensitive Data Handling</h2><h3>Password Storage</h3><pre><code>import bcrypt from 'bcrypt';\n\n// Hash password before storing\nasync function hashPassword(password) {\n  const saltRounds = 12;\n  return bcrypt.hash(password, saltRounds);\n}\n\n// Verify password\nasync function verifyPassword(password, hash) {\n  return bcrypt.compare(password, hash);\n}</code></pre><h3>Secrets in Code</h3><pre><code>// BAD - Hardcoded secrets\nconst apiKey = 'sk-123456789';\n\n// GOOD - Environment variables\nconst apiKey = process.env.API_KEY;\n\n// BETTER - Secrets manager\nimport { getSecret } from './secrets-manager';\nconst apiKey = await getSecret('api-key');</code></pre><h2>Error Handling</h2><pre><code>// BAD - Leaking internal details\napp.use((err, req, res, next) => {\n  res.status(500).json({\n    error: err.message,\n    stack: err.stack,\n    query: err.query  // SQL query exposure!\n  });\n});\n\n// GOOD - Generic error for users, detailed logs\napp.use((err, req, res, next) => {\n  // Log full error for debugging\n  logger.error('Error:', {\n    message: err.message,\n    stack: err.stack,\n    requestId: req.id\n  });\n  \n  // Return generic message to user\n  res.status(500).json({\n    error: 'An unexpected error occurred',\n    requestId: req.id  // For support reference\n  });\n});</code></pre><h2>Security Headers</h2><pre><code>// Set security headers\napp.use((req, res, next) => {\n  res.setHeader('X-Content-Type-Options', 'nosniff');\n  res.setHeader('X-Frame-Options', 'DENY');\n  res.setHeader('X-XSS-Protection', '1; mode=block');\n  res.setHeader('Strict-Transport-Security', 'max-age=31536000; includeSubDomains');\n  res.setHeader('Content-Security-Policy', \"default-src 'self'\");\n  next();\n});\n\n// Or use helmet\nimport helmet from 'helmet';\napp.use(helmet());</code></pre><h2>Conclusion</h2><p>Secure coding is a mindset. Validate all input, encode all output, use parameterized queries, and handle errors gracefully. Security is built in, not bolted on.</p>"
}
