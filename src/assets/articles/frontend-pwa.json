{
  "id": "frontend-pwa",
  "title": "Progressive Web Apps: From Zero to Production",
  "excerpt": "Build offline-capable, installable PWAs with service workers, caching strategies, push notifications, and native-like features.",
  "date": "May 2023",
  "category": "Modern Frontend",
  "readTime": 13,
  "icon": "âš¡",
  "tags": ["PWA", "Service Worker", "Offline", "Mobile"],
  "featured": false,
  "author": {
    "name": "Kamran Sohail",
    "role": "Software Engineer & Consultant",
    "avatar": "KS"
  },
  "content": "<h2>What Makes a PWA?</h2><p>Progressive Web Apps combine web technologies with native app capabilities: offline support, installability, push notifications, and fast performance.</p><h2>Web App Manifest</h2><pre><code>// manifest.json\n{\n  \"name\": \"My Awesome App\",\n  \"short_name\": \"AwesomeApp\",\n  \"description\": \"A progressive web app\",\n  \"start_url\": \"/\",\n  \"display\": \"standalone\",\n  \"background_color\": \"#ffffff\",\n  \"theme_color\": \"#3b82f6\",\n  \"orientation\": \"portrait-primary\",\n  \"icons\": [\n    {\n      \"src\": \"/icons/icon-192.png\",\n      \"sizes\": \"192x192\",\n      \"type\": \"image/png\",\n      \"purpose\": \"any maskable\"\n    },\n    {\n      \"src\": \"/icons/icon-512.png\",\n      \"sizes\": \"512x512\",\n      \"type\": \"image/png\"\n    }\n  ],\n  \"shortcuts\": [\n    {\n      \"name\": \"New Item\",\n      \"url\": \"/new\",\n      \"icons\": [{ \"src\": \"/icons/new.png\", \"sizes\": \"96x96\" }]\n    }\n  ],\n  \"screenshots\": [\n    {\n      \"src\": \"/screenshots/desktop.png\",\n      \"sizes\": \"1280x720\",\n      \"type\": \"image/png\",\n      \"form_factor\": \"wide\"\n    }\n  ]\n}</code></pre><h2>Service Worker Registration</h2><pre><code>// main.js\nif ('serviceWorker' in navigator) {\n  window.addEventListener('load', async () => {\n    try {\n      const registration = await navigator.serviceWorker.register('/sw.js', {\n        scope: '/'\n      });\n      \n      console.log('SW registered:', registration.scope);\n      \n      // Check for updates\n      registration.addEventListener('updatefound', () => {\n        const newWorker = registration.installing;\n        newWorker.addEventListener('statechange', () => {\n          if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {\n            // New version available\n            showUpdateNotification();\n          }\n        });\n      });\n    } catch (error) {\n      console.error('SW registration failed:', error);\n    }\n  });\n}</code></pre><h2>Caching Strategies</h2><pre><code>// sw.js\nconst CACHE_NAME = 'app-v1';\nconst STATIC_ASSETS = [\n  '/',\n  '/index.html',\n  '/styles.css',\n  '/app.js',\n  '/offline.html'\n];\n\n// Install: Cache static assets\nself.addEventListener('install', (event) => {\n  event.waitUntil(\n    caches.open(CACHE_NAME).then((cache) => {\n      return cache.addAll(STATIC_ASSETS);\n    })\n  );\n  self.skipWaiting();\n});\n\n// Activate: Clean old caches\nself.addEventListener('activate', (event) => {\n  event.waitUntil(\n    caches.keys().then((keys) => {\n      return Promise.all(\n        keys.filter(key => key !== CACHE_NAME).map(key => caches.delete(key))\n      );\n    })\n  );\n  self.clients.claim();\n});\n\n// Fetch: Stale-while-revalidate for API, cache-first for assets\nself.addEventListener('fetch', (event) => {\n  const { request } = event;\n  \n  if (request.url.includes('/api/')) {\n    // Network first, fallback to cache\n    event.respondWith(networkFirst(request));\n  } else {\n    // Cache first, fallback to network\n    event.respondWith(cacheFirst(request));\n  }\n});\n\nasync function cacheFirst(request) {\n  const cached = await caches.match(request);\n  if (cached) return cached;\n  \n  try {\n    const response = await fetch(request);\n    const cache = await caches.open(CACHE_NAME);\n    cache.put(request, response.clone());\n    return response;\n  } catch {\n    return caches.match('/offline.html');\n  }\n}\n\nasync function networkFirst(request) {\n  try {\n    const response = await fetch(request);\n    const cache = await caches.open(CACHE_NAME);\n    cache.put(request, response.clone());\n    return response;\n  } catch {\n    return caches.match(request);\n  }\n}</code></pre><h2>Background Sync</h2><pre><code>// Queue failed requests for later sync\nself.addEventListener('sync', (event) => {\n  if (event.tag === 'sync-messages') {\n    event.waitUntil(syncMessages());\n  }\n});\n\nasync function syncMessages() {\n  const db = await openDB('app-db', 1);\n  const messages = await db.getAll('pending-messages');\n  \n  for (const message of messages) {\n    try {\n      await fetch('/api/messages', {\n        method: 'POST',\n        body: JSON.stringify(message)\n      });\n      await db.delete('pending-messages', message.id);\n    } catch {\n      // Will retry on next sync\n      break;\n    }\n  }\n}\n\n// Register sync from app\nasync function sendMessage(message) {\n  const db = await openDB('app-db', 1);\n  await db.add('pending-messages', message);\n  \n  const registration = await navigator.serviceWorker.ready;\n  await registration.sync.register('sync-messages');\n}</code></pre><h2>Push Notifications</h2><pre><code>// Request permission and subscribe\nasync function subscribeToPush() {\n  const registration = await navigator.serviceWorker.ready;\n  \n  const subscription = await registration.pushManager.subscribe({\n    userVisibleOnly: true,\n    applicationServerKey: urlBase64ToUint8Array(VAPID_PUBLIC_KEY)\n  });\n  \n  // Send subscription to server\n  await fetch('/api/push/subscribe', {\n    method: 'POST',\n    body: JSON.stringify(subscription)\n  });\n}\n\n// Handle push in service worker\nself.addEventListener('push', (event) => {\n  const data = event.data?.json() || {};\n  \n  event.waitUntil(\n    self.registration.showNotification(data.title, {\n      body: data.body,\n      icon: '/icons/icon-192.png',\n      badge: '/icons/badge.png',\n      data: { url: data.url },\n      actions: [\n        { action: 'open', title: 'Open' },\n        { action: 'dismiss', title: 'Dismiss' }\n      ]\n    })\n  );\n});\n\nself.addEventListener('notificationclick', (event) => {\n  event.notification.close();\n  \n  if (event.action === 'open') {\n    event.waitUntil(\n      clients.openWindow(event.notification.data.url)\n    );\n  }\n});</code></pre><h2>Install Prompt</h2><pre><code>let deferredPrompt;\n\nwindow.addEventListener('beforeinstallprompt', (e) => {\n  e.preventDefault();\n  deferredPrompt = e;\n  showInstallButton();\n});\n\nasync function handleInstallClick() {\n  if (!deferredPrompt) return;\n  \n  deferredPrompt.prompt();\n  const { outcome } = await deferredPrompt.userChoice;\n  \n  if (outcome === 'accepted') {\n    console.log('App installed');\n  }\n  \n  deferredPrompt = null;\n}</code></pre><h2>Conclusion</h2><p>PWAs bridge the gap between web and native. Start with a manifest and service worker, then progressively enhance with push notifications, background sync, and offline support.</p>"
}
