{
  "id": "performance-database-optimization",
  "title": "Database Performance Tuning: From Queries to Indexes",
  "excerpt": "Diagnose and fix database performance issues with practical techniques for query optimization, indexing strategies, and schema design.",
  "date": "Dec 2023",
  "category": "Performance",
  "readTime": 14,
  "icon": "âš¡",
  "tags": ["Database", "SQL", "Optimization", "Performance"],
  "featured": false,
  "author": {
    "name": "Kamran Sohail",
    "role": "Software Engineer & Consultant",
    "avatar": "KS"
  },
  "content": "<h2>Identifying Performance Issues</h2><p>Database performance problems often manifest as slow applications. Start by identifying the bottleneck before optimizing.</p><h2>Query Analysis</h2><h3>Using EXPLAIN</h3><pre><code>EXPLAIN ANALYZE\nSELECT o.*, c.name\nFROM orders o\nJOIN customers c ON o.customer_id = c.id\nWHERE o.status = 'pending'\nORDER BY o.created_at DESC\nLIMIT 100;</code></pre><h3>What to Look For</h3><ul><li><strong>Seq Scan:</strong> Full table scans on large tables</li><li><strong>High Rows:</strong> More rows scanned than returned</li><li><strong>Sort:</strong> Expensive sorts without index support</li><li><strong>Nested Loop:</strong> Can be slow with large datasets</li></ul><h2>Indexing Strategies</h2><h3>Index Types</h3><ul><li><strong>B-Tree:</strong> Default, good for equality and range queries</li><li><strong>Hash:</strong> Fast equality lookups only</li><li><strong>GIN:</strong> Full-text search and arrays</li><li><strong>GiST:</strong> Geometric and full-text data</li></ul><h3>Composite Indexes</h3><pre><code>-- For queries filtering on status and ordering by date\nCREATE INDEX idx_orders_status_date \nON orders (status, created_at DESC);\n\n-- Column order matters!\n-- Good: WHERE status = 'pending' ORDER BY created_at\n-- Bad: WHERE created_at > '2024-01-01' (status not used)</code></pre><h3>Covering Indexes</h3><pre><code>-- Include frequently selected columns\nCREATE INDEX idx_orders_covering\nON orders (customer_id)\nINCLUDE (total, status, created_at);\n\n-- Query can be satisfied from index alone\nSELECT total, status FROM orders WHERE customer_id = 123;</code></pre><h2>Query Optimization</h2><h3>Avoid SELECT *</h3><pre><code>-- Bad: fetches unnecessary data\nSELECT * FROM orders WHERE id = 123;\n\n-- Good: fetch only what you need\nSELECT id, total, status FROM orders WHERE id = 123;</code></pre><h3>Efficient JOINs</h3><pre><code>-- Ensure join columns are indexed\nCREATE INDEX idx_orders_customer ON orders (customer_id);\n\n-- Use appropriate join type\nSELECT o.id, c.name\nFROM orders o\nINNER JOIN customers c ON o.customer_id = c.id;</code></pre><h3>Pagination</h3><pre><code>-- Bad: OFFSET for deep pagination\nSELECT * FROM orders ORDER BY id LIMIT 20 OFFSET 10000;\n\n-- Good: Keyset pagination\nSELECT * FROM orders \nWHERE id > 10000 \nORDER BY id \nLIMIT 20;</code></pre><h2>Schema Optimization</h2><h3>Denormalization</h3><p>Sometimes duplicating data improves read performance:</p><pre><code>-- Instead of joining every time\nALTER TABLE orders ADD COLUMN customer_name VARCHAR(100);\n\n-- Update via trigger or application logic</code></pre><h3>Partitioning</h3><pre><code>-- Partition large tables by date\nCREATE TABLE orders (\n    id SERIAL,\n    created_at TIMESTAMP,\n    ...\n) PARTITION BY RANGE (created_at);\n\nCREATE TABLE orders_2024_q1 \nPARTITION OF orders\nFOR VALUES FROM ('2024-01-01') TO ('2024-04-01');</code></pre><h2>Connection Management</h2><ul><li>Use connection pooling (PgBouncer, HikariCP)</li><li>Right-size pool based on workload</li><li>Monitor active connections</li></ul><h2>Monitoring</h2><pre><code>-- Find slow queries (PostgreSQL)\nSELECT query, calls, mean_time, total_time\nFROM pg_stat_statements\nORDER BY total_time DESC\nLIMIT 10;</code></pre><h2>Conclusion</h2><p>Database optimization is iterative. Measure, identify bottlenecks, optimize, and measure again. Focus on the queries that matter most.</p>"
}
