{
  "id": "security-api-security",
  "title": "API Security Best Practices for Modern Applications",
  "excerpt": "Secure your APIs with authentication, authorization, rate limiting, input validation, and protection against common attacks like injection and BOLA.",
  "date": "Dec 2023",
  "category": "Security",
  "readTime": 14,
  "icon": "ðŸ”’",
  "tags": ["API Security", "OAuth", "JWT", "OWASP"],
  "featured": false,
  "author": {
    "name": "Kamran Sohail",
    "role": "Software Engineer & Consultant",
    "avatar": "KS"
  },
  "content": "<h2>API Security Threats</h2><p>APIs are the backbone of modern applications and a prime target for attackers. The OWASP API Security Top 10 highlights the most critical risks.</p><h2>Authentication</h2><h3>OAuth 2.0 with PKCE</h3><pre><code>// Client-side PKCE flow\nasync function initiateAuth() {\n  const codeVerifier = generateRandomString(128);\n  const codeChallenge = await sha256(codeVerifier);\n  \n  // Store verifier for token exchange\n  sessionStorage.setItem('code_verifier', codeVerifier);\n  \n  const authUrl = new URL('https://auth.example.com/authorize');\n  authUrl.searchParams.set('response_type', 'code');\n  authUrl.searchParams.set('client_id', CLIENT_ID);\n  authUrl.searchParams.set('redirect_uri', REDIRECT_URI);\n  authUrl.searchParams.set('scope', 'openid profile api');\n  authUrl.searchParams.set('code_challenge', codeChallenge);\n  authUrl.searchParams.set('code_challenge_method', 'S256');\n  \n  window.location.href = authUrl.toString();\n}</code></pre><h3>JWT Validation</h3><pre><code>import jwt from 'jsonwebtoken';\nimport jwksClient from 'jwks-rsa';\n\nconst client = jwksClient({\n  jwksUri: 'https://auth.example.com/.well-known/jwks.json',\n  cache: true,\n  rateLimit: true\n});\n\nasync function validateToken(token) {\n  const decoded = jwt.decode(token, { complete: true });\n  const key = await client.getSigningKey(decoded.header.kid);\n  \n  return jwt.verify(token, key.getPublicKey(), {\n    algorithms: ['RS256'],\n    issuer: 'https://auth.example.com',\n    audience: 'your-api-audience'\n  });\n}</code></pre><h2>Authorization</h2><h3>Object-Level Authorization (BOLA Prevention)</h3><pre><code>// Always verify resource ownership\nasync function getOrder(req, res) {\n  const order = await Order.findById(req.params.orderId);\n  \n  if (!order) {\n    return res.status(404).json({ error: 'Order not found' });\n  }\n  \n  // CRITICAL: Verify the user owns this resource\n  if (order.userId !== req.user.id && !req.user.isAdmin) {\n    return res.status(403).json({ error: 'Access denied' });\n  }\n  \n  res.json(order);\n}</code></pre><h3>Function-Level Authorization</h3><pre><code>// Role-based access control middleware\nfunction requireRole(...roles) {\n  return (req, res, next) => {\n    if (!req.user || !roles.some(role => req.user.roles.includes(role))) {\n      return res.status(403).json({ error: 'Insufficient permissions' });\n    }\n    next();\n  };\n}\n\napp.delete('/users/:id', requireRole('admin'), deleteUser);\napp.post('/orders', requireRole('user', 'admin'), createOrder);</code></pre><h2>Input Validation</h2><pre><code>import { z } from 'zod';\n\nconst CreateUserSchema = z.object({\n  email: z.string().email().max(255),\n  name: z.string().min(1).max(100).regex(/^[a-zA-Z\\s]+$/),\n  age: z.number().int().min(18).max(120).optional()\n});\n\nfunction validateBody(schema) {\n  return (req, res, next) => {\n    const result = schema.safeParse(req.body);\n    if (!result.success) {\n      return res.status(400).json({\n        error: 'Validation failed',\n        details: result.error.issues\n      });\n    }\n    req.body = result.data; // Use sanitized data\n    next();\n  };\n}\n\napp.post('/users', validateBody(CreateUserSchema), createUser);</code></pre><h2>Rate Limiting</h2><pre><code>import rateLimit from 'express-rate-limit';\nimport RedisStore from 'rate-limit-redis';\n\n// General API rate limit\nconst apiLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 100,\n  standardHeaders: true,\n  store: new RedisStore({ client: redisClient }),\n  keyGenerator: (req) => req.user?.id || req.ip\n});\n\n// Strict limit for sensitive endpoints\nconst authLimiter = rateLimit({\n  windowMs: 60 * 60 * 1000, // 1 hour\n  max: 5,\n  message: 'Too many login attempts'\n});\n\napp.use('/api/', apiLimiter);\napp.post('/auth/login', authLimiter, login);</code></pre><h2>SQL Injection Prevention</h2><pre><code>// WRONG - vulnerable to SQL injection\nconst query = `SELECT * FROM users WHERE email = '${email}'`;\n\n// CORRECT - parameterized query\nconst result = await db.query(\n  'SELECT * FROM users WHERE email = $1',\n  [email]\n);\n\n// CORRECT - ORM with automatic escaping\nconst user = await User.findOne({ where: { email } });</code></pre><h2>Security Headers</h2><pre><code>import helmet from 'helmet';\n\napp.use(helmet());\napp.use(helmet.contentSecurityPolicy({\n  directives: {\n    defaultSrc: [\"'self'\"],\n    scriptSrc: [\"'self'\"],\n    styleSrc: [\"'self'\", \"'unsafe-inline'\"],\n    imgSrc: [\"'self'\", 'data:', 'https:'],\n    connectSrc: [\"'self'\", 'https://api.example.com']\n  }\n}));</code></pre><h2>Logging & Monitoring</h2><pre><code>// Security event logging\nfunction logSecurityEvent(event) {\n  const log = {\n    timestamp: new Date().toISOString(),\n    type: event.type,\n    severity: event.severity,\n    userId: event.userId,\n    ip: event.ip,\n    details: event.details\n  };\n  \n  securityLogger.log(log);\n  \n  if (event.severity === 'critical') {\n    alertService.notify(log);\n  }\n}</code></pre><h2>Conclusion</h2><p>API security requires defense in depth. Implement authentication, authorization, validation, and monitoring. Regularly audit against OWASP API Security Top 10.</p>"
}
