{
  "id": "security-authentication-patterns",
  "title": "Modern Authentication Patterns: OAuth, OIDC, and Beyond",
  "excerpt": "Master authentication implementations with OAuth 2.0, OpenID Connect, SAML, and passwordless authentication for secure modern applications.",
  "date": "Sep 2023",
  "category": "Security",
  "readTime": 13,
  "icon": "ðŸ”’",
  "tags": ["OAuth", "OIDC", "Authentication", "Identity"],
  "featured": false,
  "author": {
    "name": "Kamran Sohail",
    "role": "Software Engineer & Consultant",
    "avatar": "KS"
  },
  "content": "<h2>Authentication vs Authorization</h2><p>Authentication verifies identity (who you are). Authorization determines permissions (what you can do). Modern systems need both.</p><h2>OAuth 2.0 Flows</h2><h3>Authorization Code Flow (Web Apps)</h3><pre><code>// Step 1: Redirect to authorization server\nconst authUrl = new URL('https://auth.example.com/authorize');\nauthUrl.searchParams.set('response_type', 'code');\nauthUrl.searchParams.set('client_id', CLIENT_ID);\nauthUrl.searchParams.set('redirect_uri', 'https://app.example.com/callback');\nauthUrl.searchParams.set('scope', 'openid profile email');\nauthUrl.searchParams.set('state', generateState());\n\nwindow.location.href = authUrl.toString();\n\n// Step 2: Exchange code for tokens (server-side)\napp.get('/callback', async (req, res) => {\n  const { code, state } = req.query;\n  \n  // Verify state to prevent CSRF\n  if (state !== req.session.state) {\n    return res.status(400).send('Invalid state');\n  }\n  \n  const tokens = await fetch('https://auth.example.com/token', {\n    method: 'POST',\n    body: new URLSearchParams({\n      grant_type: 'authorization_code',\n      code,\n      redirect_uri: 'https://app.example.com/callback',\n      client_id: CLIENT_ID,\n      client_secret: CLIENT_SECRET\n    })\n  }).then(r => r.json());\n  \n  req.session.tokens = tokens;\n  res.redirect('/dashboard');\n});</code></pre><h3>Authorization Code with PKCE (SPAs, Mobile)</h3><pre><code>// Generate PKCE challenge\nfunction generateCodeVerifier() {\n  const array = new Uint8Array(32);\n  crypto.getRandomValues(array);\n  return base64UrlEncode(array);\n}\n\nasync function generateCodeChallenge(verifier) {\n  const encoder = new TextEncoder();\n  const data = encoder.encode(verifier);\n  const hash = await crypto.subtle.digest('SHA-256', data);\n  return base64UrlEncode(new Uint8Array(hash));\n}\n\n// Include in auth request\nconst codeVerifier = generateCodeVerifier();\nconst codeChallenge = await generateCodeChallenge(codeVerifier);\n\nauthUrl.searchParams.set('code_challenge', codeChallenge);\nauthUrl.searchParams.set('code_challenge_method', 'S256');\n\n// Store verifier for token exchange\nsessionStorage.setItem('code_verifier', codeVerifier);</code></pre><h2>OpenID Connect</h2><h3>ID Token Validation</h3><pre><code>import * as jose from 'jose';\n\nasync function validateIdToken(idToken) {\n  const JWKS = jose.createRemoteJWKSet(\n    new URL('https://auth.example.com/.well-known/jwks.json')\n  );\n  \n  const { payload } = await jose.jwtVerify(idToken, JWKS, {\n    issuer: 'https://auth.example.com',\n    audience: CLIENT_ID\n  });\n  \n  // Additional validations\n  if (payload.nonce !== expectedNonce) {\n    throw new Error('Invalid nonce');\n  }\n  \n  if (payload.exp < Date.now() / 1000) {\n    throw new Error('Token expired');\n  }\n  \n  return payload;\n}</code></pre><h2>Session Management</h2><pre><code>// Secure session configuration\nimport session from 'express-session';\nimport RedisStore from 'connect-redis';\n\napp.use(session({\n  store: new RedisStore({ client: redisClient }),\n  secret: process.env.SESSION_SECRET,\n  name: '__Host-session',  // Cookie prefix for security\n  resave: false,\n  saveUninitialized: false,\n  cookie: {\n    secure: true,          // HTTPS only\n    httpOnly: true,        // No JS access\n    sameSite: 'strict',    // CSRF protection\n    maxAge: 3600000        // 1 hour\n  }\n}));</code></pre><h2>Token Refresh</h2><pre><code>async function refreshTokens(refreshToken) {\n  const response = await fetch('https://auth.example.com/token', {\n    method: 'POST',\n    body: new URLSearchParams({\n      grant_type: 'refresh_token',\n      refresh_token: refreshToken,\n      client_id: CLIENT_ID\n    })\n  });\n  \n  if (!response.ok) {\n    throw new Error('Token refresh failed');\n  }\n  \n  return response.json();\n}\n\n// Automatic refresh middleware\nasync function ensureValidToken(req, res, next) {\n  const tokens = req.session.tokens;\n  \n  if (isTokenExpired(tokens.access_token)) {\n    try {\n      req.session.tokens = await refreshTokens(tokens.refresh_token);\n    } catch (error) {\n      return res.redirect('/login');\n    }\n  }\n  \n  next();\n}</code></pre><h2>Passwordless Authentication</h2><h3>WebAuthn / Passkeys</h3><pre><code>// Registration\nasync function registerPasskey() {\n  const options = await fetch('/auth/webauthn/register-options').then(r => r.json());\n  \n  const credential = await navigator.credentials.create({\n    publicKey: {\n      challenge: Uint8Array.from(options.challenge),\n      rp: { name: 'My App', id: 'app.example.com' },\n      user: {\n        id: Uint8Array.from(options.userId),\n        name: options.username,\n        displayName: options.displayName\n      },\n      pubKeyCredParams: [{ alg: -7, type: 'public-key' }],\n      authenticatorSelection: {\n        authenticatorAttachment: 'platform',\n        userVerification: 'required'\n      }\n    }\n  });\n  \n  await fetch('/auth/webauthn/register', {\n    method: 'POST',\n    body: JSON.stringify(credential)\n  });\n}</code></pre><h2>Multi-Factor Authentication</h2><pre><code>import { authenticator } from 'otplib';\n\n// Generate TOTP secret\nconst secret = authenticator.generateSecret();\nconst otpauth = authenticator.keyuri(user.email, 'MyApp', secret);\n\n// Verify TOTP code\nfunction verifyTOTP(secret, token) {\n  return authenticator.verify({ token, secret });\n}</code></pre><h2>Conclusion</h2><p>Choose the right authentication pattern for your use case. OAuth 2.0 with PKCE for SPAs, server-side tokens for web apps, and consider passwordless for better UX and security.</p>"
}
