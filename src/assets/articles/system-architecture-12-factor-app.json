{
  "id": "system-architecture-12-factor-app",
  "title": "The 12-Factor App: Cloud-Native Design Principles",
  "excerpt": "Master the twelve-factor methodology for building modern, scalable, and maintainable software-as-a-service applications.",
  "date": "Sep 2023",
  "category": "System Architecture",
  "readTime": 11,
  "icon": "üèóÔ∏è",
  "tags": ["12-Factor", "Cloud-Native", "SaaS", "Best Practices"],
  "featured": false,
  "author": {
    "name": "Kamran Sohail",
    "role": "Software Engineer & Consultant",
    "avatar": "KS"
  },
  "content": "<h2>Introduction</h2><p>The twelve-factor app methodology is a set of best practices for building modern, cloud-native applications. Originally developed by Heroku, these principles apply to any platform.</p><h2>The Twelve Factors</h2><h3>I. Codebase</h3><p>One codebase tracked in version control, many deploys. Multiple apps sharing code should extract shared code into libraries.</p><h3>II. Dependencies</h3><p>Explicitly declare and isolate dependencies. Never rely on system-wide packages:</p><pre><code>// package.json - explicit dependencies\n{\n  \"dependencies\": {\n    \"express\": \"^4.18.0\",\n    \"pg\": \"^8.11.0\"\n  }\n}</code></pre><h3>III. Config</h3><p>Store config in environment variables. Config varies between deploys; code doesn't:</p><pre><code>const dbUrl = process.env.DATABASE_URL;\nconst apiKey = process.env.API_KEY;</code></pre><h3>IV. Backing Services</h3><p>Treat backing services as attached resources. Databases, caches, and queues should be swappable without code changes:</p><pre><code># Production\nDATABASE_URL=postgres://prod-db:5432/app\n\n# Staging  \nDATABASE_URL=postgres://staging-db:5432/app</code></pre><h3>V. Build, Release, Run</h3><p>Strictly separate build and run stages:</p><ol><li><strong>Build:</strong> Convert code into executable bundle</li><li><strong>Release:</strong> Combine build with config</li><li><strong>Run:</strong> Execute app in environment</li></ol><h3>VI. Processes</h3><p>Execute the app as stateless processes. Any persistent data must be stored in a backing service:</p><pre><code>// Bad - storing state in memory\nlet sessions = {};\n\n// Good - use Redis for sessions\napp.use(session({ store: new RedisStore() }));</code></pre><h3>VII. Port Binding</h3><p>Export services via port binding. The app is self-contained and doesn't rely on runtime injection of a webserver:</p><pre><code>const port = process.env.PORT || 3000;\napp.listen(port, () => console.log(`Listening on ${port}`));</code></pre><h3>VIII. Concurrency</h3><p>Scale out via the process model. Use multiple processes for different workload types:</p><pre><code>web: node server.js\nworker: node worker.js\nscheduler: node scheduler.js</code></pre><h3>IX. Disposability</h3><p>Maximize robustness with fast startup and graceful shutdown:</p><pre><code>process.on('SIGTERM', async () => {\n  await server.close();\n  await db.disconnect();\n  process.exit(0);\n});</code></pre><h3>X. Dev/Prod Parity</h3><p>Keep development, staging, and production as similar as possible. Use Docker to ensure consistency.</p><h3>XI. Logs</h3><p>Treat logs as event streams. Write to stdout; let the environment handle aggregation:</p><pre><code>console.log(JSON.stringify({\n  level: 'info',\n  message: 'Order processed',\n  orderId: '123'\n}));</code></pre><h3>XII. Admin Processes</h3><p>Run admin/management tasks as one-off processes in identical environments:</p><pre><code>docker exec app node scripts/migrate.js</code></pre><h2>Conclusion</h2><p>Following the twelve-factor methodology creates applications that are portable, scalable, and maintainable across any cloud platform.</p>"
}
