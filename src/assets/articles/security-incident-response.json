{
  "id": "security-incident-response",
  "title": "Security Incident Response for Development Teams",
  "excerpt": "Build and execute incident response plans covering detection, containment, eradication, recovery, and post-incident analysis for security breaches.",
  "date": "Jul 2023",
  "category": "Security",
  "readTime": 11,
  "icon": "ðŸ”’",
  "tags": ["Incident Response", "Security", "DFIR", "Playbooks"],
  "featured": false,
  "author": {
    "name": "Kamran Sohail",
    "role": "Software Engineer & Consultant",
    "avatar": "KS"
  },
  "content": "<h2>Why Incident Response Matters</h2><p>Security incidents are inevitable. The difference between a minor issue and a major breach often comes down to how quickly and effectively you respond.</p><h2>Incident Response Phases</h2><ol><li><strong>Preparation:</strong> Plans, tools, training</li><li><strong>Detection:</strong> Identify potential incidents</li><li><strong>Containment:</strong> Limit the damage</li><li><strong>Eradication:</strong> Remove the threat</li><li><strong>Recovery:</strong> Restore normal operations</li><li><strong>Lessons Learned:</strong> Improve for next time</li></ol><h2>Detection and Alerting</h2><pre><code>// Centralized security logging\nconst securityLogger = {\n  log(event) {\n    const entry = {\n      timestamp: new Date().toISOString(),\n      ...event,\n      environment: process.env.NODE_ENV,\n      service: process.env.SERVICE_NAME\n    };\n    \n    // Send to SIEM\n    siem.ingest(entry);\n    \n    // Check for alert conditions\n    if (this.shouldAlert(event)) {\n      alertService.notify(entry);\n    }\n  },\n  \n  shouldAlert(event) {\n    const alertConditions = [\n      event.type === 'authentication_failure' && event.count > 5,\n      event.type === 'privilege_escalation',\n      event.type === 'data_exfiltration',\n      event.severity === 'critical'\n    ];\n    return alertConditions.some(c => c);\n  }\n};</code></pre><h2>Incident Classification</h2><pre><code>const incidentSeverity = {\n  P1: {\n    name: 'Critical',\n    response: '15 minutes',\n    examples: ['Active data breach', 'Ransomware', 'Complete service outage'],\n    escalation: ['Security Lead', 'CTO', 'Legal']\n  },\n  P2: {\n    name: 'High',\n    response: '1 hour',\n    examples: ['Suspected breach', 'Credential compromise', 'Major vulnerability'],\n    escalation: ['Security Lead', 'Engineering Lead']\n  },\n  P3: {\n    name: 'Medium',\n    response: '4 hours',\n    examples: ['Phishing attempt', 'Minor vulnerability', 'Policy violation'],\n    escalation: ['Security Team']\n  },\n  P4: {\n    name: 'Low',\n    response: '24 hours',\n    examples: ['Security scan findings', 'Audit findings'],\n    escalation: ['Security Team']\n  }\n};</code></pre><h2>Containment Playbook</h2><pre><code>// Automated containment actions\nconst containmentPlaybook = {\n  'compromised_credentials': async (incident) => {\n    // 1. Disable affected user accounts\n    await identityService.disableUser(incident.userId);\n    \n    // 2. Revoke all sessions\n    await sessionService.revokeAllSessions(incident.userId);\n    \n    // 3. Rotate API keys\n    await apiKeyService.rotateKeys(incident.userId);\n    \n    // 4. Block IP addresses\n    await waf.blockIPs(incident.sourceIPs);\n    \n    // 5. Notify user\n    await notificationService.sendSecurityAlert(incident.userId);\n  },\n  \n  'malware_detected': async (incident) => {\n    // 1. Isolate affected systems\n    await networkService.isolateHost(incident.hostId);\n    \n    // 2. Preserve evidence\n    await forensics.captureMemory(incident.hostId);\n    await forensics.captureDisks(incident.hostId);\n    \n    // 3. Block C2 domains\n    await dns.blockDomains(incident.iocs.domains);\n  }\n};</code></pre><h2>Communication Template</h2><pre><code>const incidentCommunication = {\n  internal: {\n    initial: `\n      SECURITY INCIDENT - {severity}\n      \n      What: {brief_description}\n      When: {detection_time}\n      Status: Investigation in progress\n      \n      Immediate Actions:\n      - {action_1}\n      - {action_2}\n      \n      Next Update: {time}\n      \n      Contact: {incident_commander}\n    `,\n    \n    update: `\n      INCIDENT UPDATE #{update_number}\n      \n      Status: {status}\n      Progress: {progress}\n      Next Steps: {next_steps}\n      Next Update: {time}\n    `\n  },\n  \n  external: {\n    notification: `\n      We are investigating a security incident that may have\n      affected your data. We are working with security experts\n      and will provide updates as we learn more.\n      \n      What we know: {known_impact}\n      What we're doing: {remediation_steps}\n      What you should do: {user_actions}\n    `\n  }\n};</code></pre><h2>Evidence Preservation</h2><pre><code>// Forensic evidence collection\nasync function preserveEvidence(incident) {\n  const evidence = {\n    incidentId: incident.id,\n    collectedAt: new Date().toISOString(),\n    items: []\n  };\n  \n  // Collect logs\n  evidence.items.push({\n    type: 'logs',\n    source: 'application',\n    data: await logService.export(incident.timeRange)\n  });\n  \n  // Collect network data\n  evidence.items.push({\n    type: 'network',\n    source: 'firewall',\n    data: await firewall.exportLogs(incident.timeRange)\n  });\n  \n  // Hash all evidence\n  for (const item of evidence.items) {\n    item.hash = await crypto.hash(item.data);\n  }\n  \n  // Store in immutable storage\n  await evidenceStorage.store(evidence);\n  \n  return evidence;\n}</code></pre><h2>Post-Incident Review</h2><pre><code>const postIncidentTemplate = {\n  summary: '',\n  timeline: [],\n  rootCause: '',\n  impact: {\n    systems: [],\n    data: [],\n    users: [],\n    financial: ''\n  },\n  whatWentWell: [],\n  whatCouldImprove: [],\n  actionItems: [\n    { description: '', owner: '', dueDate: '', priority: '' }\n  ],\n  lessonsLearned: []\n};</code></pre><h2>Conclusion</h2><p>Preparation is key. Have playbooks ready, practice them, and continuously improve based on lessons learned. The goal is to minimize impact and recover quickly.</p>"
}
