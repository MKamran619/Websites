{
  "id": "frontend-state-management",
  "title": "Modern State Management: Zustand, Jotai, and Beyond",
  "excerpt": "Compare modern state management solutions including Zustand, Jotai, Recoil, and signals-based approaches for React and Angular applications.",
  "date": "Oct 2023",
  "category": "Modern Frontend",
  "readTime": 13,
  "icon": "âš¡",
  "tags": ["State Management", "Zustand", "Jotai", "React"],
  "featured": false,
  "author": {
    "name": "Kamran Sohail",
    "role": "Software Engineer & Consultant",
    "avatar": "KS"
  },
  "content": "<h2>State Management Evolution</h2><p>The frontend world has moved beyond Redux. Modern solutions are simpler, more performant, and better suited to different use cases.</p><h2>Zustand - Simple & Scalable</h2><pre><code>import { create } from 'zustand';\nimport { devtools, persist } from 'zustand/middleware';\n\ninterface CartState {\n  items: CartItem[];\n  total: number;\n  addItem: (item: CartItem) => void;\n  removeItem: (id: string) => void;\n  clearCart: () => void;\n}\n\nexport const useCartStore = create<CartState>()(\n  devtools(\n    persist(\n      (set, get) => ({\n        items: [],\n        total: 0,\n        \n        addItem: (item) => set((state) => ({\n          items: [...state.items, item],\n          total: state.total + item.price\n        })),\n        \n        removeItem: (id) => set((state) => {\n          const item = state.items.find(i => i.id === id);\n          return {\n            items: state.items.filter(i => i.id !== id),\n            total: state.total - (item?.price || 0)\n          };\n        }),\n        \n        clearCart: () => set({ items: [], total: 0 })\n      }),\n      { name: 'cart-storage' }\n    )\n  )\n);\n\n// Usage in component\nfunction CartButton() {\n  const itemCount = useCartStore((state) => state.items.length);\n  return <button>Cart ({itemCount})</button>;\n}</code></pre><h2>Jotai - Atomic State</h2><pre><code>import { atom, useAtom, useAtomValue, useSetAtom } from 'jotai';\nimport { atomWithStorage } from 'jotai/utils';\n\n// Define atoms\nconst userAtom = atom<User | null>(null);\nconst themeAtom = atomWithStorage('theme', 'light');\n\n// Derived atoms\nconst isLoggedInAtom = atom((get) => get(userAtom) !== null);\n\n// Async atom\nconst userProfileAtom = atom(async (get) => {\n  const user = get(userAtom);\n  if (!user) return null;\n  const response = await fetch(`/api/users/${user.id}/profile`);\n  return response.json();\n});\n\n// Write-only atom for actions\nconst loginAtom = atom(\n  null,\n  async (get, set, credentials: { email: string; password: string }) => {\n    const response = await fetch('/api/login', {\n      method: 'POST',\n      body: JSON.stringify(credentials)\n    });\n    const user = await response.json();\n    set(userAtom, user);\n  }\n);\n\n// Usage\nfunction UserStatus() {\n  const user = useAtomValue(userAtom);\n  const isLoggedIn = useAtomValue(isLoggedInAtom);\n  const [theme, setTheme] = useAtom(themeAtom);\n  const login = useSetAtom(loginAtom);\n  \n  return (...);\n}</code></pre><h2>Redux Toolkit - When You Need It</h2><pre><code>import { createSlice, configureStore, createAsyncThunk } from '@reduxjs/toolkit';\n\n// Async thunk\nexport const fetchUsers = createAsyncThunk(\n  'users/fetch',\n  async () => {\n    const response = await fetch('/api/users');\n    return response.json();\n  }\n);\n\nconst usersSlice = createSlice({\n  name: 'users',\n  initialState: {\n    items: [] as User[],\n    status: 'idle' as 'idle' | 'loading' | 'succeeded' | 'failed',\n    error: null as string | null\n  },\n  reducers: {\n    userAdded: (state, action) => {\n      state.items.push(action.payload);\n    }\n  },\n  extraReducers: (builder) => {\n    builder\n      .addCase(fetchUsers.pending, (state) => {\n        state.status = 'loading';\n      })\n      .addCase(fetchUsers.fulfilled, (state, action) => {\n        state.status = 'succeeded';\n        state.items = action.payload;\n      })\n      .addCase(fetchUsers.rejected, (state, action) => {\n        state.status = 'failed';\n        state.error = action.error.message ?? null;\n      });\n  }\n});</code></pre><h2>TanStack Query - Server State</h2><pre><code>import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';\n\n// Fetch data with caching\nfunction useUsers() {\n  return useQuery({\n    queryKey: ['users'],\n    queryFn: () => fetch('/api/users').then(r => r.json()),\n    staleTime: 5 * 60 * 1000, // 5 minutes\n  });\n}\n\n// Mutations with optimistic updates\nfunction useCreateUser() {\n  const queryClient = useQueryClient();\n  \n  return useMutation({\n    mutationFn: (newUser: CreateUserDto) =>\n      fetch('/api/users', {\n        method: 'POST',\n        body: JSON.stringify(newUser)\n      }).then(r => r.json()),\n      \n    onMutate: async (newUser) => {\n      await queryClient.cancelQueries({ queryKey: ['users'] });\n      const previous = queryClient.getQueryData(['users']);\n      queryClient.setQueryData(['users'], (old: User[]) => [\n        ...old,\n        { ...newUser, id: 'temp' }\n      ]);\n      return { previous };\n    },\n    \n    onError: (err, newUser, context) => {\n      queryClient.setQueryData(['users'], context?.previous);\n    },\n    \n    onSettled: () => {\n      queryClient.invalidateQueries({ queryKey: ['users'] });\n    }\n  });\n}</code></pre><h2>Choosing the Right Solution</h2><table><tr><th>Solution</th><th>Best For</th></tr><tr><td>Zustand</td><td>Simple global state, easy migration from Redux</td></tr><tr><td>Jotai</td><td>Atomic state, fine-grained updates</td></tr><tr><td>Redux Toolkit</td><td>Complex state logic, middleware needs</td></tr><tr><td>TanStack Query</td><td>Server state, caching, sync</td></tr><tr><td>React Context</td><td>Theme, auth, small shared state</td></tr></table><h2>Conclusion</h2><p>Match your state management to your needs. Use TanStack Query for server state, lightweight solutions like Zustand for client state, and Context for simple sharing.</p>"
}
