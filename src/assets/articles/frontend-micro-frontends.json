{
  "id": "frontend-micro-frontends",
  "title": "Micro Frontends: Scaling Frontend Development",
  "excerpt": "Break monolithic frontends into independently deployable micro frontends using Module Federation, Single-SPA, and Web Components.",
  "date": "Jun 2023",
  "category": "Modern Frontend",
  "readTime": 14,
  "icon": "âš¡",
  "tags": ["Micro Frontends", "Module Federation", "Architecture", "Scaling"],
  "featured": false,
  "author": {
    "name": "Kamran Sohail",
    "role": "Software Engineer & Consultant",
    "avatar": "KS"
  },
  "content": "<h2>Why Micro Frontends?</h2><p>As frontend applications grow, they become difficult to maintain. Micro frontends allow teams to work independently, deploy separately, and use different technologies.</p><h2>Module Federation (Webpack 5)</h2><h3>Host Application</h3><pre><code>// webpack.config.js (Host)\nconst ModuleFederationPlugin = require('webpack/lib/container/ModuleFederationPlugin');\n\nmodule.exports = {\n  plugins: [\n    new ModuleFederationPlugin({\n      name: 'host',\n      remotes: {\n        // Load remote micro frontends\n        products: 'products@http://localhost:3001/remoteEntry.js',\n        checkout: 'checkout@http://localhost:3002/remoteEntry.js',\n        profile: 'profile@http://localhost:3003/remoteEntry.js'\n      },\n      shared: {\n        react: { singleton: true, requiredVersion: '^18.0.0' },\n        'react-dom': { singleton: true, requiredVersion: '^18.0.0' }\n      }\n    })\n  ]\n};</code></pre><h3>Remote Application</h3><pre><code>// webpack.config.js (Products micro frontend)\nconst ModuleFederationPlugin = require('webpack/lib/container/ModuleFederationPlugin');\n\nmodule.exports = {\n  plugins: [\n    new ModuleFederationPlugin({\n      name: 'products',\n      filename: 'remoteEntry.js',\n      exposes: {\n        './ProductList': './src/components/ProductList',\n        './ProductDetail': './src/components/ProductDetail'\n      },\n      shared: {\n        react: { singleton: true },\n        'react-dom': { singleton: true }\n      }\n    })\n  ]\n};</code></pre><h3>Loading Remote Components</h3><pre><code>// In host application\nimport React, { Suspense, lazy } from 'react';\n\n// Dynamic import of remote component\nconst ProductList = lazy(() => import('products/ProductList'));\nconst Checkout = lazy(() => import('checkout/CheckoutForm'));\n\nfunction App() {\n  return (\n    <div>\n      <Suspense fallback={<div>Loading products...</div>}>\n        <ProductList />\n      </Suspense>\n      \n      <Suspense fallback={<div>Loading checkout...</div>}>\n        <Checkout />\n      </Suspense>\n    </div>\n  );\n}</code></pre><h2>Single-SPA Approach</h2><pre><code>// Root config\nimport { registerApplication, start } from 'single-spa';\n\nregisterApplication({\n  name: '@myorg/navbar',\n  app: () => System.import('@myorg/navbar'),\n  activeWhen: () => true // Always active\n});\n\nregisterApplication({\n  name: '@myorg/products',\n  app: () => System.import('@myorg/products'),\n  activeWhen: (location) => location.pathname.startsWith('/products')\n});\n\nregisterApplication({\n  name: '@myorg/checkout',\n  app: () => System.import('@myorg/checkout'),\n  activeWhen: '/checkout'\n});\n\nstart();</code></pre><pre><code>// Products micro frontend\nimport { registerApplication } from 'single-spa';\nimport singleSpaReact from 'single-spa-react';\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nconst lifecycles = singleSpaReact({\n  React,\n  ReactDOM,\n  rootComponent: App,\n  domElementGetter: () => document.getElementById('products-container')\n});\n\nexport const { bootstrap, mount, unmount } = lifecycles;</code></pre><h2>Communication Between Micro Frontends</h2><pre><code>// Custom event bus\nclass EventBus {\n  private events: Record<string, Function[]> = {};\n  \n  subscribe(event: string, callback: Function) {\n    this.events[event] = this.events[event] || [];\n    this.events[event].push(callback);\n    \n    return () => {\n      this.events[event] = this.events[event].filter(cb => cb !== callback);\n    };\n  }\n  \n  publish(event: string, data: any) {\n    (this.events[event] || []).forEach(callback => callback(data));\n  }\n}\n\n// Expose globally\nwindow.__EVENT_BUS__ = window.__EVENT_BUS__ || new EventBus();\n\n// Usage in Products MFE\nwindow.__EVENT_BUS__.publish('cart:add', { productId: '123', quantity: 1 });\n\n// Usage in Cart MFE\nwindow.__EVENT_BUS__.subscribe('cart:add', (item) => {\n  addToCart(item);\n});</code></pre><h2>Shared State</h2><pre><code>// Shared state using RxJS\nimport { BehaviorSubject } from 'rxjs';\n\ninterface User {\n  id: string;\n  name: string;\n  email: string;\n}\n\n// Create shared store\nconst userSubject = new BehaviorSubject<User | null>(null);\n\nexport const userStore = {\n  getUser: () => userSubject.getValue(),\n  setUser: (user: User) => userSubject.next(user),\n  subscribe: (callback: (user: User | null) => void) => {\n    const subscription = userSubject.subscribe(callback);\n    return () => subscription.unsubscribe();\n  }\n};\n\n// Expose as singleton\nwindow.__USER_STORE__ = window.__USER_STORE__ || userStore;</code></pre><h2>Routing Coordination</h2><pre><code>// Shell router that delegates to micro frontends\nfunction ShellRouter() {\n  return (\n    <Router>\n      <Route path=\"/products/*\" element={\n        <Suspense fallback={<Spinner />}>\n          <ProductsMicroFrontend />\n        </Suspense>\n      } />\n      <Route path=\"/checkout/*\" element={\n        <Suspense fallback={<Spinner />}>\n          <CheckoutMicroFrontend />\n        </Suspense>\n      } />\n      <Route path=\"/profile/*\" element={\n        <Suspense fallback={<Spinner />}>\n          <ProfileMicroFrontend />\n        </Suspense>\n      } />\n    </Router>\n  );\n}</code></pre><h2>When to Use Micro Frontends</h2><ul><li>Large teams needing autonomy</li><li>Multiple products sharing components</li><li>Gradual migration from legacy systems</li><li>Different release cycles needed</li></ul><h2>Conclusion</h2><p>Micro frontends solve organizational scaling, not technical problems. Use them when team independence and separate deployability justify the added complexity.</p>"
}
